ğŸ”Œ 1. Gunakan 1 koneksi gRPC persisten (jangan sering reconnect)

Pastikan semua traffic di-multiplex lewat 1 long-lived HTTP/2 connection.
Gunakan gRPC streaming (bi-directional) untuk data tunnel, bukan unary call berulang-ulang.

Keuntungannya:

tidak ada TLS handshake berulang

tidak ada TCP slow-start berulang

latency jauh lebih stabil

ğŸš€ 2. Pakai gRPC streaming untuk data tunnel

Yang paling cepat adalah bidirectional streaming:

client â†’ server: data dari local port

server â†’ client: data dari remote side

Ini menghindari overhead request/response gRPC biasa.

âš™ï¸ 3. Set keepalive & flow control gRPC

Supaya koneksi tetap hidup dan tidak ditutup idle timeout provider / firewall:

grpc.Dial(
    addr,
    grpc.WithInsecure(),
    grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(64<<20)),
    grpc.WithKeepaliveParams(keepalive.ClientParameters{
        Time:                30 * time.Second,
        Timeout:             10 * time.Second,
        PermitWithoutStream: true,
    }),
)

ğŸ”„ 4. Nonaktifkan compression gRPC untuk payload kecil

Compression itu mahal CPU-nya â€” cocok hanya untuk payload >10KB.
Kalau traffic kamu kecil & sering â†’ disable compression.

ğŸ“¦ 5. Minimalkan overhead protobuf

gunakan bytes untuk payload raw

hindari nested struct dalam-dalam

hindari repeated kecil-kecil â†’ lebih baik buffer

Setiap serialize/deserialize itu cost.

ğŸ›œ 6. Optimalkan TCP layer
Aktifkan TCP_NODELAY

Supaya tidak nunggu Nagleâ€™s Algorithm (delay packet kecil):

conn, _ := net.Dial(...)
tcpConn := conn.(*net.TCPConn)
tcpConn.SetNoDelay(true)


Ini mengurangi latency request kecil (misal HTTP header proxy).

ğŸ“¶ 7. Pastikan koneksi stabil (MTU, packet loss, RTT)

Tunnel sangat sensitif pada:

âœ” RTT tinggi
âœ” Packet loss kecil
âœ” MTU mismatch (ICMP blocked â†’ fragmentation â†’ lambat)

Jika bisa, pakai:

server dekat user (region tepat)

gunakan Anycast/CDN ingress bila skala besar

ğŸ§  8. Gunakan buffering & batching

Jangan kirim byte per byte.
Kirim minimal 4â€“16 KB per write.

Manfaat:

lebih sedikit syscalls

throughput naik

Di Go, gunakan bufio.Reader/Writer.

ğŸ§ª 9. Pilih protokol yang pas

gRPC = HTTP/2 di atas TCP (bagus tapi ada overhead).
Untuk trafik murni tunnel, alternatif:

Opsi	Kapan dipakai
gRPC bidirectional streaming	paling mudah + tetap cepat
HTTP/2 raw stream	overhead sedikit lebih rendah
QUIC / HTTP/3	jaringan high-loss / mobile
custom mux (yamux/smux)	performa maksimal

Kalau mau tetap gRPC tapi lebih tahan loss â†’ coba gRPC over HTTP/3 (QUIC).

ğŸ” 10. TLS cipher & session tuning

TLS itu mahal. Optimasi:

aktifkan session resumption

gunakan cipher modern (AES-GCM / ChaCha20)

hindari renegotiation

Kalau jalur internal â†’ kadang TLS termination di edge load balancer.

ğŸ§ 11. Tuning OS (Linux)

Di server, aktifkan:

sysctl -w net.core.rmem_max=2500000
sysctl -w net.core.wmem_max=2500000
sysctl -w net.ipv4.tcp_congestion_control=bbr


BBR sangat membantu throughput di latency tinggi.

ğŸ“Š 12. Monitoring dulu, optimasi kemudian

Pasang metrics:

latency per hop

packet per stream

reconnect count

CPU encode/decode protobuf

TLS handshake time

Grafana + Prometheus cocok (sepertinya kamu sudah pakai ğŸ™‚)

ğŸ§¯ 13. Hindari hal-hal ini (biasanya bikin lambat)

âŒ unary gRPC untuk setiap request
âŒ reconnect tiap traffic masuk
âŒ kirim payload super kecil tanpa buffering
âŒ compression on untuk payload kecil
âŒ proxy berlapis-lapis (Nginx â†’ H2 â†’ gRPC â†’ tunnel)
âŒ logging terlalu verbose

ğŸ§© 14. Arsitektur mirip ngrok (best-practice)

Biasanya:

Client

1 control connection (metadata)

1 data tunnel connection (multiplexed)

Server

listener â†’ router stream per tunnel

keepalive + health check

auto-reconnect client bila link down